package cosan

import (
"strings"
"sync"
)

// radixMatcher implements Matcher using a radix tree for efficient path matching.
// It supports:
// - Static paths: /users/profile
// - Named parameters: /users/:id
// - Wildcard parameters: /files/*path
type radixMatcher struct {
mu       sync.RWMutex
trees    map[string]*radixNode // One tree per HTTP method
compiled bool
}

// radixNode represents a node in the radix tree.
type radixNode struct {
// Path segment for this node (without parameter markers)
path string

// Node type
nType nodeType

// Parameter name (for param and wildcard nodes)
paramName string

// Handler route at this node (nil if intermediate node)
route *Route

// Children nodes (for static and param nodes)
children []*radixNode

// Wildcard child (for catch-all routes)
wildcard *radixNode

// Priority for conflict resolution (higher = checked first)
priority int
}

// nodeType represents the type of radix tree node.
type nodeType uint8

const (
staticNode   nodeType = iota // Static path segment
paramNode                    // Named parameter (:id)
wildcardNode                 // Catch-all parameter (*path)
)

// newRadixMatcher creates a new radix tree matcher.
func newRadixMatcher() *radixMatcher {
return &radixMatcher{
trees: make(map[string]*radixNode),
}
}

// Add registers a route in the radix tree.
func (m *radixMatcher) Add(method, pattern string, route Route) error {
m.mu.Lock()
defer m.mu.Unlock()

if m.compiled {
return ErrRouterCompiled
}

// Get or create tree for this method
tree := m.trees[method]
if tree == nil {
tree = &radixNode{
nType: staticNode,
}
m.trees[method] = tree
}

// Insert route into tree
if err := m.insertRoute(tree, pattern, &route); err != nil {
return err
}

return nil
}

// insertRoute inserts a route into the radix tree.
func (m *radixMatcher) insertRoute(node *radixNode, pattern string, route *Route) error {
// Remove leading slash
pattern = strings.TrimPrefix(pattern, "/")

// If pattern is empty, set route at current node
if pattern == "" {
if node.route != nil {
return ErrConflictingRoutes
}
node.route = route
return nil
}

// Find next segment
segment, remaining := m.splitPath(pattern)

// Determine segment type
if strings.HasPrefix(segment, ":") {
// Named parameter
paramName := segment[1:]
return m.insertParam(node, paramName, remaining, route)
} else if strings.HasPrefix(segment, "*") {
// Wildcard parameter
paramName := segment[1:]
return m.insertWildcard(node, paramName, route)
} else {
// Static segment
return m.insertStatic(node, segment, remaining, route)
}
}

// insertStatic inserts a static path segment.
func (m *radixMatcher) insertStatic(node *radixNode, segment, remaining string, route *Route) error {
// Look for existing child with matching prefix
for _, child := range node.children {
if child.nType == staticNode {
// Find common prefix
commonLen := longestCommonPrefix(segment, child.path)

if commonLen == len(child.path) {
// Exact match or child is prefix of segment
if commonLen == len(segment) {
// Exact match - continue with remaining path
return m.insertRoute(child, remaining, route)
}
// Child is prefix - continue with rest of segment
newSegment := segment[commonLen:]
return m.insertRoute(child, newSegment+remaining, route)
} else if commonLen > 0 {
// Partial match - need to split the node
m.splitNode(child, commonLen)
// Continue insertion from the split point
return m.insertStatic(node, segment, remaining, route)
}
}
}

// No matching child - create new node
newNode := &radixNode{
path:     segment,
nType:    staticNode,
priority: 100, // Static nodes have high priority
}
node.children = append(node.children, newNode)

// Continue with remaining path
return m.insertRoute(newNode, remaining, route)
}

// insertParam inserts a parameter node.
func (m *radixMatcher) insertParam(node *radixNode, paramName, remaining string, route *Route) error {
// Look for existing param node with same name
for _, child := range node.children {
if child.nType == paramNode && child.paramName == paramName {
return m.insertRoute(child, remaining, route)
}
}

// Create new param node
newNode := &radixNode{
nType:     paramNode,
paramName: paramName,
priority:  50, // Params have medium priority
}
node.children = append(node.children, newNode)

return m.insertRoute(newNode, remaining, route)
}

// insertWildcard inserts a wildcard node.
func (m *radixMatcher) insertWildcard(node *radixNode, paramName string, route *Route) error {
if node.wildcard != nil {
return ErrConflictingRoutes
}

node.wildcard = &radixNode{
nType:     wildcardNode,
paramName: paramName,
route:     route,
priority:  10, // Wildcards have low priority
}

return nil
}

// splitNode splits a node at the given position.
func (m *radixMatcher) splitNode(node *radixNode, pos int) {
// Create new child with the remaining path
newChild := &radixNode{
path:     node.path[pos:],
nType:    node.nType,
route:    node.route,
children: node.children,
wildcard: node.wildcard,
priority: node.priority,
}

// Update current node to be prefix
node.path = node.path[:pos]
node.route = nil
node.children = []*radixNode{newChild}
node.wildcard = nil
}

// splitPath splits a path into the next segment and remaining path.
func (m *radixMatcher) splitPath(path string) (segment, remaining string) {
if path == "" {
return "", ""
}

// Find next slash
i := strings.Index(path, "/")
if i == -1 {
return path, ""
}

return path[:i], path[i+1:]
}

// Compile prepares the matcher for use.
func (m *radixMatcher) Compile() error {
m.mu.Lock()
defer m.mu.Unlock()

if m.compiled {
return nil
}

// Sort children by priority for each node
for _, tree := range m.trees {
m.sortByPriority(tree)
}

m.compiled = true
return nil
}

// sortByPriority recursively sorts children by priority.
func (m *radixMatcher) sortByPriority(node *radixNode) {
if node == nil {
return
}

// Sort children: static first, then params, wildcard last
// Within each type, sort by priority
for i := 0; i < len(node.children); i++ {
for j := i + 1; j < len(node.children); j++ {
if node.children[j].priority > node.children[i].priority {
node.children[i], node.children[j] = node.children[j], node.children[i]
}
}
}

// Recursively sort children
for _, child := range node.children {
m.sortByPriority(child)
}
}

// Match finds a route matching the given method and path.
func (m *radixMatcher) Match(method, path string) (*Route, map[string]string, bool) {
m.mu.RLock()
defer m.mu.RUnlock()

tree := m.trees[method]
if tree == nil {
return nil, nil, false
}

// Remove leading slash
path = strings.TrimPrefix(path, "/")

params := make(map[string]string)
route := m.search(tree, path, params)

if route != nil {
return route, params, true
}

return nil, nil, false
}

// search recursively searches for a matching route.
func (m *radixMatcher) search(node *radixNode, path string, params map[string]string) *Route {
// If path is empty, return route at this node
if path == "" {
return node.route
}

// Try static children first
for _, child := range node.children {
if child.nType == staticNode {
if strings.HasPrefix(path, child.path) {
remaining := path[len(child.path):]
if remaining == "" || remaining[0] == '/' {
// Matched - remove leading slash from remaining
remaining = strings.TrimPrefix(remaining, "/")
if route := m.search(child, remaining, params); route != nil {
return route
}
}
}
}
}

// Try param children
for _, child := range node.children {
if child.nType == paramNode {
// Find next segment
segment, remaining := m.splitPath(path)
if segment != "" {
// Save param value
params[child.paramName] = segment
if route := m.search(child, remaining, params); route != nil {
return route
}
// Backtrack - remove param
delete(params, child.paramName)
}
}
}

// Try wildcard
if node.wildcard != nil {
params[node.wildcard.paramName] = path
return node.wildcard.route
}

return nil
}

// longestCommonPrefix returns the length of the longest common prefix.
func longestCommonPrefix(a, b string) int {
max := len(a)
if len(b) < max {
max = len(b)
}

for i := 0; i < max; i++ {
if a[i] != b[i] {
return i
}
}

return max
}
